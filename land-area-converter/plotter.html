<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Land Area Plotter</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .plotting-area {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            position: relative;
            min-height: 550px;
        }
        
        #canvas {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            display: block;
            margin: 0 auto;
            cursor: crosshair;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .zoom-controls button {
            background: linear-gradient(to right, #4dabf7, #3b5bdb);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to right, #3b5bdb, #4dabf7);
        }
        
        .zoom-controls button:active {
            transform: translateY(0);
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        h2 i {
            color: #4dabf7;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            background: linear-gradient(to right, #4dabf7, #3b5bdb);
            color: white;
            border: none;
            padding: 12px 15px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to right, #3b5bdb, #4dabf7);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background: linear-gradient(to right, #20c997, #12b886);
        }
        
        button.warning {
            background: linear-gradient(to right, #ff6b6b, #f03e3e);
        }
        
        button.active {
            background: linear-gradient(to right, #f39c12, #e67e22);
            box-shadow: 0 0 0 2px #fff;
        }
        
        .instructions {
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .instructions li {
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        
        .instructions li i {
            color: #4dabf7;
            margin-top: 3px;
        }
        
        .dimension-input {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
        }
        
        .dimension-input label {
            flex: 1;
            font-weight: 500;
        }
        
        .dimension-input input {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            width: 100px;
            text-align: center;
        }
        
        .dimension-input select {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            width: 80px;
        }
        
        .results {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-value {
            font-weight: 700;
            font-size: 1.2rem;
            color: #4dabf7;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.3);
            font-weight: 500;
        }
        
        .status.warning {
            background: rgba(231, 76, 60, 0.3);
            color: #ff9f9f;
        }
        
        .status.success {
            background: rgba(46, 204, 113, 0.3);
            color: #a9ffcf;
        }
        
        .status.info {
            background: rgba(52, 152, 219, 0.3);
            color: #a9d6ff;
        }
        
        .close-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(46, 204, 113, 0.3);
            border: 2px solid #2ecc71;
            display: none;
            pointer-events: none;
            z-index: 10;
            animation: pulse 1.5s infinite;
        }
        
        .dimension-display {
            display: block;
        }
        
        .side-selection {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
        }
        
        .side-btn {
            flex: 1;
            margin: 0 5px;
            text-align: center;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 0.4; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .zoom-controls {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-ruler-combined"></i> Professional Land Area Plotter</h1>
            <p class="subtitle">Plot, measure, and calculate land areas with advanced features</p>
        </header>
        
        <main class="plotting-area">
            <div id="closeIndicator" class="close-indicator"></div>
            <canvas id="canvas" width="750" height="550"></canvas>
            <div class="zoom-controls">
                <button id="panButton"><i class="fas fa-hand-paper"></i></button>
                <button id="zoomIn"><i class="fas fa-search-plus"></i></button>
                <button id="zoomOut"><i class="fas fa-search-minus"></i></button>
                <button id="undo" class="warning"><i class="fas fa-undo"></i></button>
                <button id="export"><i class="fas fa-download"></i></button>
            </div>
        </main>
        
        <aside class="controls">
            <div class="panel">
                <h2><i class="fas fa-tools"></i> Controls</h2>
                <div class="btn-group">
                    <button id="optimize"><i class="fas fa-magic"></i> Optimize</button>
                    <button id="calculateArea" class="secondary"><i class="fas fa-calculator"></i> Calculate Area</button>
                    <button id="clear" class="warning"><i class="fas fa-trash"></i> Clear All</button>
                    <button id="addDiagonal"><i class="fas fa-plus-circle"></i> Add Diagonal</button>
                    <button id="closeShape"><i class="fas fa-draw-polygon"></i> Close Shape</button>
                    <button id="dragMode"><i class="fas fa-arrows-alt"></i> Drag Points</button>
                </div>
                
                <div class="dimension-input">
                    <label><i class="fas fa-ruler"></i> Edge Length:</label>
                    <input type="number" id="lengthInput" step="0.01" min="0.1" placeholder="Enter length">
                    <select id="lengthUnit">
                        <option value="meters">Meters</option>
                        <option value="feet">Feet</option>
                    </select>
                </div>
                
                <div class="status" id="statusDisplay">
                    <i class="fas fa-info-circle"></i> Ready to plot. Click to add points.
                </div>
            </div>
            
            <div class="panel" id="slicePanel">
                <h2><i class="fas fa-cut"></i> Slice Shape</h2>
                <div class="dimension-input">
                    <label><i class="fas fa-ruler-combined"></i> Area to slice:</label>
                    <input type="number" id="sliceAreaInput" step="0.01" min="0.1" placeholder="Enter area">
                    <select id="areaUnit">
                        <option value="squareMeters">m²</option>
                        <option value="squareFeet">ft²</option>
                        <option value="acres">Acres</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button id="startSlice"><i class="fas fa-cut"></i> Start Slice</button>
                    <button id="cancelSlice" class="warning"><i class="fas fa-times"></i> Cancel</button>
                    <button id="confirmSlice" class="secondary" style="display:none;"><i class="fas fa-check"></i> Confirm Slice</button>
                </div>
                <div class="side-selection" id="sideSelection" style="display:none;">
                    <button class="side-btn" id="leftSide"><i class="fas fa-arrow-left"></i> Left Side</button>
                    <button class="side-btn" id="rightSide"><i class="fas fa-arrow-right"></i> Right Side</button>
                </div>
                <div class="status" id="sliceStatus">
                    <i class="fas fa-info-circle"></i> Enter area and click Start Slice.
                </div>
            </div>
            
            <div class="panel">
                <h2><i class="fas fa-book"></i> Instructions</h2>
                <ol class="instructions">
                    <li><i class="fas fa-mouse-pointer"></i> Click canvas to add points</li>
                    <li><i class="fas fa-dot-circle"></i> Close shape near first point or with button</li>
                    <li><i class="fas fa-ruler-horizontal"></i> Click edges to set lengths</li>
                    <li><i class="fas fa-arrows-alt"></i> Enable Drag Points to move vertices</li>
                    <li><i class="fas fa-plus-circle"></i> Add diagonals for complex shapes</li>
                    <li><i class="fas fa-calculator"></i> Calculate area for measurements</li>
                    <li><i class="fas fa-trash"></i> Double-click edges to delete</li>
                    <li><i class="fas fa-download"></i> Export data as JSON</li>
                </ol>
            </div>
            
            <div class="panel results">
                <h2><i class="fas fa-chart-area"></i> Area Calculation</h2>
                <div class="result-item">
                    <span>Area in Square Meters:</span>
                    <span id="areaMeters" class="result-value">0.00</span>
                </div>
                <div class="result-item">
                    <span>Area in Square Feet:</span>
                    <span id="areaFeet" class="result-value">0.00</span>
                </div>
                <div class="result-item">
                    <span>Area in Acres:</span>
                    <span id="areaAcres" class="result-value">0.00</span>
                </div>
                <div class="result-item">
                    <span>Perimeter:</span>
                    <span id="perimeter" class="result-value">0.00 m</span>
                </div>
            </div>
        </aside>
        
        <footer>
            <p>Professional Land Area Plotter © 2025 | Advanced surveying tool</p>
        </footer>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const lengthInput = document.getElementById('lengthInput');
        const lengthUnit = document.getElementById('lengthUnit');
        const areaUnit = document.getElementById('areaUnit');
        const statusDisplay = document.getElementById('statusDisplay');
        const areaMeters = document.getElementById('areaMeters');
        const areaFeet = document.getElementById('areaFeet');
        const areaAcres = document.getElementById('areaAcres');
        const perimeter = document.getElementById('perimeter');
        const closeIndicator = document.getElementById('closeIndicator');
        const closeShapeBtn = document.getElementById('closeShape');
        const addDiagonalBtn = document.getElementById('addDiagonal');
        const undoBtn = document.getElementById('undo');
        const sliceAreaInput = document.getElementById('sliceAreaInput');
        const startSliceBtn = document.getElementById('startSlice');
        const cancelSliceBtn = document.getElementById('cancelSlice');
        const confirmSliceBtn = document.getElementById('confirmSlice');
        const sliceStatus = document.getElementById('sliceStatus');
        const sideSelection = document.getElementById('sideSelection');
        const leftSideBtn = document.getElementById('leftSide');
        const rightSideBtn = document.getElementById('rightSide');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const panButton = document.getElementById('panButton');
        const optimizeBtn = document.getElementById('optimize');
        const calculateAreaBtn = document.getElementById('calculateArea');
        const clearBtn = document.getElementById('clear');
        const exportBtn = document.getElementById('export');
        const dragModeBtn = document.getElementById('dragMode');

        // Drawing state
        let points = [];
        let edges = [];
        let isShapeClosed = false;
        let selectedEdge = null;
        let scaleFactor = 1;
        let showCloseIndicator = false;

        // Undo state
        let undoStack = [];
        const UNDO_LIMIT = 5;

        // Diagonal mode state
        let diagonalMode = false;
        let firstDiagonalPoint = null;

        // Slice mode state
        let sliceMode = false;
        let sliceStartPoint = null;
        let sliceLine = null;
        let sliceLineFinalized = false;
        let targetSliceArea = 0;
        let sliceDirection = null;
        let sliceOriginalEdges = null;
        let sliceIntersections = [];
        let leftPoly = [];
        let rightPoly = [];

        // Drag mode state
        let dragMode = false;
        let draggedPointIndex = -1;

        // Pan and Zoom state
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastX = 0;
        let lastY = 0;
        let isPanMode = false;
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 10.0;

        // Conversion factors
        const METERS_TO_FEET = 3.28084;
        const SQUARE_METERS_TO_SQUARE_FEET = METERS_TO_FEET ** 2;
        const SQUARE_METERS_TO_ACRES = 1 / 4046.86;

        // Initialize
        draw();
        updateStatus("Click on the canvas to add the first point", "info");

        // Draw the current state
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scale, scale);
            ctx.translate(offsetX, offsetY);

            // Draw grid
            drawGrid();

            // Draw edges
            edges.forEach(function(edge, index) {
                const start = points[edge.startIndex];
                const end = points[edge.endIndex];

                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.lineWidth = edge.isSliceEdge ? 4 / scale : 3 / scale;
                ctx.strokeStyle = edge.isSliceEdge ? '#2ecc71' : 
                                edge === selectedEdge ? '#4dabf7' : '#333';
                ctx.stroke();

                if (!sliceMode && edge.length) {
                    const midX = (start.x + end.x) / 2;
                    const midY = (start.y + end.y) / 2;
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    const unit = edge.unit || 'meters';
                    ctx.fillText(`${edge.length.toFixed(2)} ${unit === 'meters' ? 'm' : 'ft'}`, midX, midY - 10 / scale);
                }
            });

            // Draw sliced polygons
            if (leftPoly.length > 0 && rightPoly.length > 0) {
                ctx.beginPath();
                ctx.moveTo(leftPoly[0].x, leftPoly[0].y);
                for (let i = 1; i < leftPoly.length; i++) {
                    ctx.lineTo(leftPoly[i].x, leftPoly[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(rightPoly[0].x, rightPoly[0].y);
                for (let i = 1; i < rightPoly.length; i++) {
                    ctx.lineTo(rightPoly[i].x, rightPoly[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fill();
            }

            // Draw points
            points.forEach(function(point, index) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, point.highlight ? 8 / scale : 6 / scale, 0, Math.PI * 2);
                ctx.fillStyle = point.highlight ? '#3498db' : 
                               (index === 0 && points.length > 2 ? '#2ecc71' : '#e74c3c');
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('P' + (index + 1), point.x, point.y + 20 / scale);
            });

            // Draw polygon fill if closed
            if (isShapeClosed && points.length >= 3 && leftPoly.length === 0) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
                ctx.fill();
            }

            // Draw slice line
            if (sliceMode && sliceLine) {
                ctx.beginPath();
                ctx.moveTo(sliceLine.start.x, sliceLine.start.y);
                ctx.lineTo(sliceLine.end.x, sliceLine.end.y);
                ctx.lineWidth = 3 / scale;
                ctx.strokeStyle = sliceLineFinalized ? '#2ecc71' : '#e74c3c';
                ctx.setLineDash(sliceLineFinalized ? [] : [5 / scale, 5 / scale]);
                ctx.stroke();
                ctx.setLineDash([]);

                if (sliceDirection) {
                    const midX = (sliceLine.start.x + sliceLine.end.x) / 2;
                    const midY = (sliceLine.start.y + sliceLine.end.y) / 2;

                    ctx.beginPath();
                    ctx.arc(midX, midY, 5 / scale, 0, Math.PI * 2);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fill();

                    ctx.font = 'bold 12px Arial';
                    const unit = areaUnit.value;
                    const areaText = unit === 'squareMeters' ? `${targetSliceArea.toFixed(2)} m²` :
                                    unit === 'squareFeet' ? `${(targetSliceArea * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2)} ft²` :
                                    `${(targetSliceArea * SQUARE_METERS_TO_ACRES).toFixed(4)} acres`;
                    ctx.fillText(`Target: ${areaText}`, midX, midY - 15 / scale);
                }
            }

            // Draw intersection points and legend
            if (sliceIntersections.length > 0 && sliceLineFinalized) {
                const intersectionA = sliceIntersections[0];
                const intersectionB = sliceIntersections[1];

                ctx.beginPath();
                ctx.arc(intersectionA.x, intersectionA.y, 6 / scale, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();
                ctx.fillText('A', intersectionA.x, intersectionA.y + 15 / scale);

                ctx.beginPath();
                ctx.arc(intersectionB.x, intersectionB.y, 6 / scale, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();
                ctx.fillText('B', intersectionB.x, intersectionB.y + 15 / scale);

                const legendY = (canvas.height / scale) - 50 / scale - offsetY;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(10 / scale - offsetX, legendY, (canvas.width - 20) / scale, 40 / scale);
                ctx.strokeStyle = '#ccc';
                ctx.strokeRect(10 / scale - offsetX, legendY, (canvas.width - 20) / scale, 40 / scale);

                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';

                const totalPoints = points.length;
                const aIndex = points.findIndex(p => Math.abs(p.x - intersectionA.x) < 0.1 && Math.abs(p.y - intersectionA.y) < 0.1);
                const bIndex = points.findIndex(p => Math.abs(p.x - intersectionB.x) < 0.1 && Math.abs(p.y - intersectionB.y) < 0.1);

                let legendText = '';
                let leftArea = 0, rightArea = 0;

                if (aIndex !== -1 && bIndex !== -1) {
                    const p5 = points[(aIndex - 1 + totalPoints) % totalPoints];
                    const p1 = points[(aIndex + 1) % totalPoints];
                    const p3 = points[(bIndex - 1 + totalPoints) % totalPoints];
                    const p2 = points[(bIndex + 1) % totalPoints];

                    const p5aDist = Math.sqrt(Math.pow(p5.x - intersectionA.x, 2) + Math.pow(p5.y - intersectionA.y, 2)) * scaleFactor;
                    const ap1Dist = Math.sqrt(Math.pow(p1.x - intersectionA.x, 2) + Math.pow(p1.y - intersectionA.y, 2)) * scaleFactor;
                    const p3bDist = Math.sqrt(Math.pow(p3.x - intersectionB.x, 2) + Math.pow(p3.y - intersectionB.y, 2)) * scaleFactor;
                    const b2Dist = Math.sqrt(Math.pow(p2.x - intersectionB.x, 2) + Math.pow(p2.y - intersectionB.y, 2)) * scaleFactor;
                    const abDist = Math.sqrt(Math.pow(intersectionB.x - intersectionA.x, 2) + Math.pow(intersectionB.y - intersectionA.y, 2)) * scaleFactor;

                    leftArea = calculatePolygonArea(leftPoly);
                    rightArea = calculatePolygonArea(rightPoly);

                    const unit = lengthUnit.value;
                    const distText = unit === 'meters' ? 'm' : 'ft';
                    const areaUnitText = areaUnit.value;
                    const leftAreaText = areaUnitText === 'squareMeters' ? `${leftArea.toFixed(2)} m²` :
                                        areaUnitText === 'squareFeet' ? `${(leftArea * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2)} ft²` :
                                        `${(leftArea * SQUARE_METERS_TO_ACRES).toFixed(4)} acres`;
                    const rightAreaText = areaUnitText === 'squareMeters' ? `${rightArea.toFixed(2)} m²` :
                                        areaUnitText === 'squareFeet' ? `${(rightArea * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2)} ft²` :
                                        `${(rightArea * SQUARE_METERS_TO_ACRES).toFixed(4)} acres`;

                    legendText = `New Dimensions: P${(aIndex - 1 + totalPoints) % totalPoints + 1}-A: ${p5aDist.toFixed(2)} ${distText}, A-P${aIndex + 2}: ${ap1Dist.toFixed(2)} ${distText}, P${(bIndex - 1 + totalPoints) % totalPoints + 1}-B: ${p3bDist.toFixed(2)} ${distText}, B-P${bIndex + 2}: ${b2Dist.toFixed(2)} ${distText}, A-B: ${abDist.toFixed(2)} ${distText} | Areas: Left: ${leftAreaText}, Right: ${rightAreaText}`;
                }

                ctx.fillText(legendText, (15 / scale) - offsetX, legendY + (15 / scale));
            }

            ctx.restore();
            updateAreaDisplay();
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = 1 / scale;

            for (let x = Math.floor(-offsetX / 25) * 25; x <= (canvas.width / scale) - offsetX; x += 25) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height / scale);
                ctx.stroke();
            }

            for (let y = Math.floor(-offsetY / 25) * 25; y <= (canvas.height / scale) - offsetY; y += 25) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width / scale, y);
                ctx.stroke();
            }
        }

        function updateStatus(message, type) {
            type = type || "info";
            statusDisplay.className = "status";
            if (type === "warning") statusDisplay.classList.add("warning");
            if (type === "success") statusDisplay.classList.add("success");
            if (type === "info") statusDisplay.classList.add("info");

            const iconClass = type === "info" ? "info-circle" : 
                            type === "warning" ? "exclamation-triangle" : 
                            "check-circle";

            statusDisplay.innerHTML = `<i class="fas fa-${iconClass}"></i> ${message}`;
        }

        function updateSliceStatus(message, type) {
            type = type || "info";
            sliceStatus.className = "status";
            if (type === "warning") sliceStatus.classList.add("warning");
            if (type === "success") sliceStatus.classList.add("success");
            if (type === "info") sliceStatus.classList.add("info");

            const iconClass = type === "info" ? "info-circle" : 
                            type === "warning" ? "exclamation-triangle" : 
                            "check-circle";

            sliceStatus.innerHTML = `<i class="fas fa-${iconClass}"></i> ${message}`;
        }

        function updateAreaDisplay() {
            if (!isShapeClosed || points.length < 3) {
                areaMeters.textContent = "0.00";
                areaFeet.textContent = "0.00";
                areaAcres.textContent = "0.00";
                perimeter.textContent = `0.00 ${lengthUnit.value === 'meters' ? 'm' : 'ft'}`;
                return;
            }

            const area = calculateArea();
            const perimeterValue = calculatePerimeter();

            areaMeters.textContent = area.toFixed(2);
            areaFeet.textContent = (area * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2);
            areaAcres.textContent = (area * SQUARE_METERS_TO_ACRES).toFixed(4);
            perimeter.textContent = `${(lengthUnit.value === 'meters' ? perimeterValue : perimeterValue * METERS_TO_FEET).toFixed(2)} ${lengthUnit.value === 'meters' ? 'm' : 'ft'}`;
        }

        function calculateArea() {
            if (edges.length === 0) return 0;

            let pixelArea = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                pixelArea += points[i].x * points[j].y;
                pixelArea -= points[i].y * points[j].x;
            }
            pixelArea = Math.abs(pixelArea / 2);

            let totalRealLength = 0;
            let totalPixelLength = 0;

            edges.forEach(function(edge) {
                if (edge.length) {
                    const p1 = points[edge.startIndex];
                    const p2 = points[edge.endIndex];
                    const pixelLength = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    totalRealLength += edge.unit === 'feet' ? edge.length / METERS_TO_FEET : edge.length;
                    totalPixelLength += pixelLength;
                }
            });

            if (totalRealLength > 0 && totalPixelLength > 0) {
                scaleFactor = totalRealLength / totalPixelLength;
            }

            return pixelArea * scaleFactor * scaleFactor;
        }

        function calculatePerimeter() {
            let total = 0;

            edges.forEach(function(edge) {
                if (edge.length) {
                    total += edge.unit === 'feet' ? edge.length / METERS_TO_FEET : edge.length;
                } else {
                    const p1 = points[edge.startIndex];
                    const p2 = points[edge.endIndex];
                    const pixelLength = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    total += pixelLength * scaleFactor;
                }
            });

            return total;
        }

        function calculateEdgeLength(edge) {
            const p1 = points[edge.startIndex];
            const p2 = points[edge.endIndex];
            const pixelLength = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            return pixelLength * scaleFactor;
        }

        function getNearPoint(x, y) {
            const rect = canvas.getBoundingClientRect();
            const transformedX = (x - rect.left) / scale - offsetX;
            const transformedY = (y - rect.top) / scale - offsetY;
            
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const distance = Math.sqrt(
                    Math.pow(point.x - transformedX, 2) + 
                    Math.pow(point.y - transformedY, 2)
                );
                if (distance < 15 / scale) return i;
            }
            return -1;
        }

        function getNearEdge(x, y) {
            const rect = canvas.getBoundingClientRect();
            const transformedX = (x - rect.left) / scale - offsetX;
            const transformedY = (y - rect.top) / scale - offsetY;
            
            let nearestEdgeIndex = -1;
            let minDistance = Infinity;
            
            for (let i = 0; i < edges.length; i++) {
                const edge = edges[i];
                const p1 = points[edge.startIndex];
                const p2 = points[edge.endIndex];

                const A = transformedX - p1.x;
                const B = transformedY - p1.y;
                const C = p2.x - p1.x;
                const D = p2.y - p1.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) param = dot / lenSq;

                let xx, yy;
                if (param < 0) {
                    xx = p1.x;
                    yy = p1.y;
                } else if (param > 1) {
                    xx = p2.x;
                    yy = p2.y;
                } else {
                    xx = p1.x + param * C;
                    yy = p1.y + param * D;
                }

                const distance = Math.sqrt(Math.pow(transformedX - xx, 2) + Math.pow(transformedY - yy, 2));
                if (distance < 10 / scale && distance < minDistance) {
                    minDistance = distance;
                    nearestEdgeIndex = i;
                }
            }
            return nearestEdgeIndex;
        }

       function closeShape() {
            if (isShapeClosed) return;

            if (points.length >= 3) {
                edges.push({ startIndex: points.length - 1, endIndex: 0, length: null });
                isShapeClosed = true;
                updateStatus("Shape closed! Add dimensions to edges or calculate area.", "success");
                showCloseIndicator = false;
                closeIndicator.style.display = 'none';
                draw();
            } else {
                updateStatus("Need at least 3 points to close a shape", "warning");
            }
        }

        // Handle adding diagonals
        function handleDiagonalClick(x, y) {
            const pointIndex = getNearPoint(x, y);

            if (pointIndex === -1) {
                updateStatus("Please click on an existing point to add a diagonal", "warning");
                return;
            }

            if (firstDiagonalPoint === null) {
                firstDiagonalPoint = pointIndex;
                points[pointIndex].highlight = true;
                updateStatus("Selected point P" + (pointIndex + 1) + ". Click another point to complete diagonal.", "info");
                draw();
            } else if (firstDiagonalPoint === pointIndex) {
                updateStatus("Cannot create diagonal to the same point", "warning");
            } else {
                // Check if edge already exists
                const edgeExists = edges.some(function(edge) {
                    return (edge.startIndex === firstDiagonalPoint && edge.endIndex === pointIndex) ||
                           (edge.startIndex === pointIndex && edge.endIndex === firstDiagonalPoint);
                });

                if (edgeExists) {
                    updateStatus("Edge already exists between these points", "warning");
                } else {
                    edges.push({
                        startIndex: firstDiagonalPoint,
                        endIndex: pointIndex,
                        length: null
                    });
                    updateStatus("Diagonal added between P" + (firstDiagonalPoint + 1) + " and P" + (pointIndex + 1), "success");
                }

                // Reset diagonal mode
                points[firstDiagonalPoint].highlight = false;
                firstDiagonalPoint = null;
                exitDiagonalMode();
                draw();
            }
        }

        // Enter diagonal mode
        function enterDiagonalMode() {
            if (!isShapeClosed || points.length < 4) {
                updateStatus("Need a closed shape with at least 4 points to add diagonals", "warning");
                return false;
            }

            diagonalMode = true;
            addDiagonalBtn.classList.add('active');
            updateStatus("Diagonal mode: Click two points to add a diagonal between them", "info");
            return true;
        }

        // Exit diagonal mode
        function exitDiagonalMode() {
            diagonalMode = false;
            addDiagonalBtn.classList.remove('active');
            if (firstDiagonalPoint !== null) {
                points[firstDiagonalPoint].highlight = false;
                firstDiagonalPoint = null;
            }
        }


        function optimizeShape() {
            if (!isShapeClosed || points.length < 3) {
                updateStatus("Please close the shape first", "warning");
                return;
            }

            const edgesWithLength = edges.filter(e => e.length).length;
            if (edgesWithLength < 2) {
                updateStatus("Add at least 2 edge lengths to optimize", "warning");
                return;
            }

            const oldPoints = points.slice();
            const oldEdges = edges.slice();

            for (let iter = 0; iter < 50; iter++) {
                edges.forEach(function(edge) {
                    if (!edge.length) return;

                    const p1 = points[edge.startIndex];
                    const p2 = points[edge.endIndex];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const currentLength = Math.sqrt(dx * dx + dy * dy);
                    const targetLength = edge.unit === 'feet' ? edge.length / METERS_TO_FEET : edge.length / scaleFactor;

                    if (currentLength === 0) return;

                    const ratio = targetLength / currentLength;
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    if (edge.startIndex !== 0) {
                        p1.x = midX + (p1.x - midX) * ratio;
                        p1.y = midY + (p1.y - midY) * ratio;
                    }
                    if (edge.endIndex !== 0) {
                        p2.x = midX + (p2.x - midX) * ratio;
                        p2.y = midY + (p2.y - midY) * ratio;
                    }
                });
            }

            undoStack.push({ action: 'optimize', points: oldPoints, edges: oldEdges });
            if (undoStack.length > UNDO_LIMIT) undoStack.shift();
            updateStatus("Shape optimized to match provided measurements", "success");
            isPanMode = false;
            dragMode = false;
            dragModeBtn.classList.remove('active');
            panButton.classList.remove('active');
            canvas.style.cursor = 'crosshair';
            draw();
        }

        function prepareForSlicing() {
            if (!isShapeClosed || points.length < 3) {
                updateSliceStatus("Need a closed shape to slice", "warning");
                return false;
            }

            optimizeShape();

            sliceOriginalEdges = edges.slice();
            edges = edges.filter(function(edge) {
                return Math.abs(edge.startIndex - edge.endIndex) === 1 || 
                       Math.abs(edge.startIndex - edge.endIndex) === points.length - 1;
            });

            const totalArea = calculateArea();
            targetSliceArea = parseFloat(sliceAreaInput.value);
            if (areaUnit.value === 'squareFeet') {
                targetSliceArea /= SQUARE_METERS_TO_SQUARE_FEET;
            } else if (areaUnit.value === 'acres') {
                targetSliceArea /= SQUARE_METERS_TO_ACRES;
            }

            if (isNaN(targetSliceArea) || targetSliceArea <= 0) {
                updateSliceStatus("Please enter a valid positive area", "warning");
                edges = sliceOriginalEdges;
                sliceOriginalEdges = null;
                return false;
            }

            if (targetSliceArea >= totalArea) {
                updateSliceStatus(`Slice area must be less than total area (${totalArea.toFixed(2)} m²)`, "warning");
                edges = sliceOriginalEdges;
                sliceOriginalEdges = null;
                return false;
            }

            sliceMode = true;
            sliceLineFinalized = false;
            leftPoly = [];
            rightPoly = [];

            updateSliceStatus("Click to set the start point of the slice line", "info");
            updateStatus("Slice mode: Click to set start point", "info");
            isPanMode = false;
            dragMode = false;
            dragModeBtn.classList.remove('active');
            panButton.classList.remove('active');
            canvas.style.cursor = 'crosshair';
            draw();

            return true;
        }

        function exitSliceMode() {
            sliceMode = false;
            sliceStartPoint = null;
            sliceLine = null;
            sliceLineFinalized = false;
            sliceDirection = null;
            sliceIntersections = [];
            leftPoly = [];
            rightPoly = [];

            if (sliceOriginalEdges) {
                edges = sliceOriginalEdges;
                sliceOriginalEdges = null;
            }

            sideSelection.style.display = 'none';
            confirmSliceBtn.style.display = 'none';
            updateSliceStatus("Enter area and click Start Slice.", "info");
            updateStatus("Slice mode canceled", "info");
            isPanMode = false;
            dragMode = false;
            dragModeBtn.classList.remove('active');
            panButton.classList.remove('active');
            canvas.style.cursor = 'crosshair';
            draw();
        }

        function findLineIntersection(p1, p2, p3, p4) {
            const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

            if (Math.abs(denominator) < 0.0001) return null;

            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return {
                    x: p1.x + ua * (p2.x - p1.x),
                    y: p1.y + ua * (p2.y - p1.y)
                };
            }
            return null;
        }

        function isPointOnSegment(p, p1, p2) {
            const crossProduct = (p.y - p1.y) * (p2.x - p1.x) - (p.x - p1.x) * (p2.y - p1.y);
            if (Math.abs(crossProduct) > 0.1) return false;

            const dotProduct = (p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y);
            if (dotProduct < 0) return false;

            const squaredLength = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y);
            if (dotProduct > squaredLength) return false;

            return true;
        }

        function findIntersectionsWithPolygon(line) {
            const intersections = [];

            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                const edgeStart = points[i];
                const edgeEnd = points[j];

                const intersect = findLineIntersection(
                    line.start, line.end,
                    edgeStart, edgeEnd
                );

                if (intersect && isPointOnSegment(intersect, edgeStart, edgeEnd)) {
                    intersections.push({
                        point: intersect,
                        edgeIndex: i
                    });
                }
            }

            intersections.sort((a, b) => a.point.y - b.point.y);
            return intersections.map(i => i.point);
        }

        function calculatePolygonArea(verts) {
            let area = 0;
            for (let i = 0; i < verts.length; i++) {
                const j = (i + 1) % verts.length;
                area += verts[i].x * verts[j].y;
                area -= verts[j].x * verts[i].y;
            }
            return Math.abs(area / 2) * scaleFactor * scaleFactor;
        }

        function getSlicedPolygons(line, direction) {
            let intersections = findIntersectionsWithPolygon(line);
            if (intersections.length < 2) return { left: [], right: [] };

            intersections = intersections.slice(0, 2);

            let leftVerts = [];
            let rightVerts = [];
            const lineVec = { x: line.end.x - line.start.x, y: line.end.y - line.start.y };

            for (let i = 0; i < points.length; i++) {
                const v = points[i];
                const cross = (line.end.x - line.start.x) * (v.y - line.start.y) - 
                              (line.end.y - line.start.y) * (v.x - line.start.x);
                if (direction === 'left') {
                    if (cross <= 0) leftVerts.push(v);
                    if (cross >= 0) rightVerts.push(v);
                } else {
                    if (cross >= 0) leftVerts.push(v);
                    if (cross <= 0) rightVerts.push(v);
                }
            }

            leftVerts.push(...intersections);
            rightVerts.push(...intersections);

            const centerX = (intersections[0].x + intersections[1].x) / 2;
            const centerY = (intersections[0].y + intersections[1].y) / 2;
            leftVerts.sort((a, b) => {
                const angleA = Math.atan2(a.y - centerY, a.x - centerX);
                const angleB = Math.atan2(b.y - centerY, b.x - centerX);
                return angleA - angleB;
            });
            rightVerts.sort((a, b) => {
                const angleA = Math.atan2(a.y - centerY, a.x - centerX);
                const angleB = Math.atan2(b.y - centerY, b.x - centerX);
                return angleA - angleB;
            });

            if (leftVerts.length < 3 || rightVerts.length < 3) {
                return { left: [], right: [] };
            }

            return { left: leftVerts, right: rightVerts };
        }

       function adjustSliceToTargetArea() {
            if (!sliceLine || !sliceDirection) return;

            const intersections = findIntersectionsWithPolygon(sliceLine);
            if (intersections.length !== 2) {
                updateSliceStatus("Invalid slice line - must intersect exactly two edges.", "warning");
                sliceLine = null;
                sliceStartPoint = null;
                sliceLineFinalized = false;
                sideSelection.style.display = 'none';
                updateStatus("Slice mode: Click to set start point", "info");
                draw();
                return;
            }

            const lineVec = { x: sliceLine.end.x - sliceLine.start.x, y: sliceLine.end.y - sliceLine.start.y };
            const length = Math.sqrt(lineVec.x * lineVec.x + lineVec.y * lineVec.y);
            if (length < 0.1) {
                updateSliceStatus("Slice line too short.", "warning");
                sliceLine = null;
                sliceStartPoint = null;
                sliceLineFinalized = false;
                sideSelection.style.display = 'none';
                updateStatus("Slice mode: Click to set start point", "info");
                draw();
                return;
            }

            const dirVec = { x: lineVec.x / length, y: lineVec.y / length };
            const normalVec = { x: -dirVec.y, y: dirVec.x };

            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            const maxOffset = Math.min(maxX - minX, maxY - minY) * 0.5;

            let low = -maxOffset;
            let high = maxOffset;
            let bestOffset = 0;
            let bestAreaDiff = Infinity;
            const targetArea = targetSliceArea;
            const errorMargin = 0.1;
            sliceIntersections = [];
            let bestLine;

            for (let i = 0; i < 100; i++) {
                const offset = (low + high) / 2;
                const movedLine = {
                    start: { x: sliceLine.start.x + normalVec.x * offset, y: sliceLine.start.y + normalVec.y * offset },
                    end: { x: sliceLine.end.x + normalVec.x * offset, y: sliceLine.end.y + normalVec.y * offset }
                };

                const newIntersections = findIntersectionsWithPolygon(movedLine);
                if (newIntersections.length !== 2) continue;

                const validIntersections = newIntersections.filter(intersect => 
                    intersect.x >= minX && intersect.x <= maxX && intersect.y >= minY && intersect.y <= maxY
                );
                if (validIntersections.length !== 2) continue;

                const { left, right } = getSlicedPolygons(movedLine, sliceDirection);
                if (left.length < 3 || right.length < 3) continue;

                const achievedArea = calculatePolygonArea(sliceDirection === 'left' ? left : right);
                const areaDiff = Math.abs(achievedArea - targetArea);

                if (areaDiff < bestAreaDiff) {
                    bestAreaDiff = areaDiff;
                    bestOffset = offset;
                    bestLine = movedLine;
                    sliceIntersections = validIntersections;
                    leftPoly = left;
                    rightPoly = right;
                }

                if (bestAreaDiff <= errorMargin) break;

                if (achievedArea < targetArea) {
                    low = offset;
                } else {
                    high = offset;
                }

                if (Math.abs(high - low) < 0.0001) break;
            }

            if (bestLine) {
                sliceLine = bestLine;

                const achievedArea = calculatePolygonArea(sliceDirection === 'left' ? leftPoly : rightPoly);
                const otherArea = calculatePolygonArea(sliceDirection === 'left' ? rightPoly : leftPoly);
                const totalSlicedArea = achievedArea + otherArea;
                const areaError = Math.abs(totalSlicedArea - calculateArea());

                const slope = (sliceLine.end.y - sliceLine.start.y) / (sliceLine.end.x - sliceLine.start.x);
                const intercept = sliceLine.start.y - slope * sliceLine.start.x;
                const lineEq = `y = ${(slope * scaleFactor).toFixed(2)}x + ${(intercept * scaleFactor).toFixed(2)}`;

                const areaUnitText = areaUnit.value;
                const achievedAreaText = areaUnitText === 'squareMeters' ? `${achievedArea.toFixed(2)} m²` :
                                       areaUnitText === 'squareFeet' ? `${(achievedArea * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2)} ft²` :
                                       `${(achievedArea * SQUARE_METERS_TO_ACRES).toFixed(4)} acres`;
                const otherAreaText = areaUnitText === 'squareMeters' ? `${otherArea.toFixed(2)} m²` :
                                     areaUnitText === 'squareFeet' ? `${(otherArea * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2)} ft²` :
                                     `${(otherArea * SQUARE_METERS_TO_ACRES).toFixed(4)} acres`;
                const totalAreaText = areaUnitText === 'squareMeters' ? `${totalSlicedArea.toFixed(2)} m²` :
                                     areaUnitText === 'squareFeet' ? `${(totalSlicedArea * SQUARE_METERS_TO_SQUARE_FEET).toFixed(2)} ft²` :
                                     `${(totalSlicedArea * SQUARE_METERS_TO_ACRES).toFixed(4)} acres`;

                updateSliceStatus(
                    `Slice optimized. Target area: ${achievedAreaText}, Other side: ${otherAreaText}, Total sliced: ${totalAreaText}, Error: ${areaError.toFixed(2)} m², Line: ${lineEq}`,
                    areaError <= errorMargin ? "success" : "warning"
                );

                confirmSliceBtn.style.display = 'block';
                draw();
            } else {
                updateSliceStatus("Could not find valid slice position within 0.1 m² error.", "warning");
                sliceLine = null;
                sliceStartPoint = null;
                sliceLineFinalized = false;
                sideSelection.style.display = 'none';
                updateStatus("Slice mode: Click to set start point", "info");
                draw();
            }
        }

        function confirmSlice() {
            if (!sliceLine || sliceIntersections.length !== 2) {
                updateSliceStatus("Could not find valid slice points", "warning");
                return;
            }

            const newPoint1 = {
                x: sliceIntersections[0].x,
                y: sliceIntersections[0].y,
                isSlicePoint: true
            };

            const newPoint2 = {
                x: sliceIntersections[1].x,
                y: sliceIntersections[1].y,
                isSlicePoint: true
            };

            let insertIndex1 = -1;
            let insertIndex2 = -1;

            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                if (isPointOnSegment(sliceIntersections[0], points[i], points[j])) {
                    insertIndex1 = j;
                }
                if (isPointOnSegment(sliceIntersections[1], points[i], points[j])) {
                    insertIndex2 = j;
                }
            }

            if (insertIndex1 < insertIndex2) {
                points.splice(insertIndex1, 0, newPoint1);
                points.splice(insertIndex2 + 1, 0, newPoint2);
            } else {
                points.splice(insertIndex2, 0, newPoint2);
                points.splice(insertIndex1 + 1, 0, newPoint1);
            }

            edges = [];
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;

                let originalEdge = null;
                for (let k = 0; k < sliceOriginalEdges.length; k++) {
                    const edge = sliceOriginalEdges[k];
                    const p1 = points[edge.startIndex];
                    const p2 = points[edge.endIndex];

                    if ((p1 === points[i] && p2 === points[j]) || 
                        (p1 === points[j] && p2 === points[i])) {
                        originalEdge = edge;
                        break;
                    }
                }

                if (Math.abs(i - j) === 1 || (i === 0 && j === points.length - 1) || (i === points.length - 1 && j === 0)) {
                    edges.push({
                        startIndex: i,
                        endIndex: j,
                        length: originalEdge ? originalEdge.length : null,
                        unit: originalEdge ? originalEdge.unit : 'meters',
                        isSliceEdge: false
                    });
                }
            }

            const sliceEdgeIndex1 = points.indexOf(newPoint1);
            const sliceEdgeIndex2 = points.indexOf(newPoint2);

            edges.push({
                startIndex: sliceEdgeIndex1,
                endIndex: sliceEdgeIndex2,
                length: calculateEdgeLength({
                    startIndex: sliceEdgeIndex1,
                    endIndex: sliceEdgeIndex2
                }),
                unit: 'meters',
                isSliceEdge: true
            });

            undoStack.push({ action: 'slice', points: points.slice(), edges: edges.slice() });
            if (undoStack.length > UNDO_LIMIT) undoStack.shift();

            sliceMode = false;
            sliceStartPoint = null;
            sliceLine = null;
            sliceLineFinalized = true;
            sliceDirection = null;

            updateSliceStatus("Slice confirmed and applied", "success");
            isPanMode = false;
            dragMode = false;
            dragModeBtn.classList.remove('active');
            panButton.classList.remove('active');
            canvas.style.cursor = 'crosshair';
            draw();
        }

        function exportData() {
            const data = {
                points: points.map(p => ({ x: p.x, y: p.y })),
                edges: edges.map(e => ({
                    startIndex: e.startIndex,
                    endIndex: e.endIndex,
                    length: e.length,
                    unit: e.unit
                })),
                area: calculateArea(),
                perimeter: calculatePerimeter(),
                isShapeClosed: isShapeClosed,
                scaleFactor: scaleFactor
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'land_plot.json';
            a.click();
            URL.revokeObjectURL(url);
            updateStatus("Data exported as JSON", "success");
        }

        // Canvas event handlers
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isPanMode || e.shiftKey) {
                isPanning = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = 'grab';
            } else if (dragMode && isShapeClosed) {
                draggedPointIndex = getNearPoint(e.clientX, e.clientY);
                if (draggedPointIndex !== -1) {
                    points[draggedPointIndex].highlight = true;
                    canvas.style.cursor = 'grabbing';
                    draw();
                }
            }
        });

        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const transformedX = x / scale - offsetX;
            const transformedY = y / scale - offsetY;

            if (sliceMode && sliceStartPoint && !sliceLineFinalized) {
                sliceLine = {
                    start: sliceStartPoint,
                    end: { x: transformedX, y: transformedY }
                };
                draw();
                return;
            }

            if (isPanning) {
                const dx = (e.clientX - lastX) / scale;
                const dy = (e.clientY - lastY) / scale;
                offsetX += dx;
                offsetY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
                return;
            }

            if (dragMode && draggedPointIndex !== -1) {
                points[draggedPointIndex].x = transformedX;
                points[draggedPointIndex].y = transformedY;
                draw();
                return;
            }

            if (isShapeClosed || points.length < 3) return;

            const firstPoint = points[0];
            const distance = Math.sqrt(Math.pow(firstPoint.x - transformedX, 2) + Math.pow(firstPoint.y - transformedY, 2));

            if (distance < 15 / scale) {
                showCloseIndicator = true;
                closeIndicator.style.display = 'block';
                closeIndicator.style.left = (firstPoint.x * scale + offsetX * scale + rect.left - 20) + 'px';
                closeIndicator.style.top = (firstPoint.y * scale + offsetY * scale + rect.top - 20) + 'px';
            } else {
                showCloseIndicator = false;
                closeIndicator.style.display = 'none';
            }
        });

        canvas.addEventListener('mouseup', function(e) {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = isPanMode ? 'grab' : 'crosshair';
            }
            if (dragMode && draggedPointIndex !== -1) {
                points[draggedPointIndex].highlight = false;
                undoStack.push({ action: 'dragPoint', points: points.slice(), edges: edges.slice() });
                if (undoStack.length > UNDO_LIMIT) undoStack.shift();
                draggedPointIndex = -1;
                canvas.style.cursor = 'crosshair';
                draw();
            }
        });

        canvas.addEventListener('mouseleave', function() {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = isPanMode ? 'grab' : 'crosshair';
            }
            if (dragMode && draggedPointIndex !== -1) {
                points[draggedPointIndex].highlight = false;
                draggedPointIndex = -1;
                canvas.style.cursor = 'crosshair';
                draw();
            }
        });

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const zoom = e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * zoom));

            if (newScale !== scale) {
                const mouseX = (e.clientX - canvas.getBoundingClientRect().left) / scale;
                const mouseY = (e.clientY - canvas.getBoundingClientRect().top) / scale;
                offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
                offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
                scale = newScale;
                draw();
            }
        });

        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const transformedX = x / scale - offsetX;
            const transformedY = y / scale - offsetY;

            if (diagonalMode) {
                handleDiagonalClick(e.clientX, e.clientY);
                return;
            }

            if (sliceMode) {
                if (!sliceStartPoint) {
                    sliceStartPoint = { x: transformedX, y: transformedY };
                    sliceLine = {
                        start: sliceStartPoint,
                        end: sliceStartPoint
                    };
                    updateSliceStatus("Click to set the end point of the slice line", "info");
                    draw();
                } else if (!sliceLineFinalized) {
                    sliceLine = {
                        start: sliceStartPoint,
                        end: { x: transformedX, y: transformedY }
                    };
                    const intersections = findIntersectionsWithPolygon(sliceLine);
                    if (intersections.length === 2) {
                        sliceLineFinalized = true;
                        sideSelection.style.display = 'flex';
                        updateSliceStatus("Select which side should be the target area", "info");
                    } else {
                        updateSliceStatus("Invalid slice line - must intersect exactly two edges.", "warning");
                        sliceLine = null;
                        sliceStartPoint = null;
                        sliceLineFinalized = false;
                        updateStatus("Slice mode: Click to set start point", "info");
                    }
                    draw();
                }
                return;
            }

            if (dragMode) return;

            // FIX: Pass client coordinates (e.clientX, e.clientY) to helper functions
            const edgeIndex = getNearEdge(e.clientX, e.clientY);
            
            if (edgeIndex !== -1 && !diagonalMode && !sliceMode) {
                selectedEdge = edges[edgeIndex];
                lengthInput.value = selectedEdge.length || '';
                lengthUnit.value = selectedEdge.unit || 'meters';
                lengthInput.focus();
                updateStatus(`Editing edge between P${selectedEdge.startIndex + 1} and P${selectedEdge.endIndex + 1}. Enter length.`, "info");
                draw();
                return;
            }

            if (!isShapeClosed && points.length >= 3) {
                // FIX: Pass client coordinates (e.clientX, e.clientY) to helper functions
                const nearIndex = getNearPoint(e.clientX, e.clientY);
                if (nearIndex === 0) {
                    closeShape();
                    return;
                }
            } 

            if (!isShapeClosed) {
                const newPoint = { x: transformedX, y: transformedY, highlight: false };
                points.push(newPoint);

                if (points.length > 1) {
                    const newEdge = { 
                        startIndex: points.length - 2, 
                        endIndex: points.length - 1, 
                        length: null,
                        unit: 'meters'
                    };
                    edges.push(newEdge);
                    undoStack.push({ action: 'addPoint', point: newPoint, edge: newEdge, points: points.slice(), edges: edges.slice() });
                } else {
                    undoStack.push({ action: 'addPoint', point: newPoint, points: points.slice() });
                }

                if (undoStack.length > UNDO_LIMIT) undoStack.shift();

                if (points.length === 1) {
                    updateStatus("Added first point. Click to add more points.", "info");
                } else if (points.length === 3) {
                    updateStatus("Click near P1 to close the shape or continue adding points.", "info");
                } else {
                    updateStatus(`Point P${points.length} added. Click near P1 to close.`, "info");
                }
            } else {
                selectedEdge = null;
            }

            draw();
        });

        canvas.addEventListener('dblclick', function(e) {
            if (diagonalMode || sliceMode || dragMode) return;
            
            // FIX: Pass client coordinates (e.clientX, e.clientY) to helper functions
            const edgeIndex = getNearEdge(e.clientX, e.clientY);
            if (edgeIndex !== -1) {
                const oldEdges = edges.slice();
                edges.splice(edgeIndex, 1);

                if (isShapeClosed) {
                    isShapeClosed = !edges.some(function(edge) { 
                        return (edge.startIndex === 0 && edge.endIndex === points.length - 1) ||
                               (edge.startIndex === points.length - 1 && edge.endIndex === 0);
                    });
                }

                undoStack.push({ action: 'deleteEdge', edgeIndex: edgeIndex, edges: oldEdges });
                if (undoStack.length > UNDO_LIMIT) undoStack.shift();

                updateStatus("Edge deleted", "info");
                draw();
            }
        });

        lengthInput.addEventListener('change', function() {
            if (selectedEdge) {
                const value = parseFloat(lengthInput.value);
                if (!isNaN(value) && value > 0) {
                    const oldLength = selectedEdge.length;
                    const oldUnit = selectedEdge.unit;
                    selectedEdge.length = value;
                    selectedEdge.unit = lengthUnit.value;
                    undoStack.push({ action: 'setLength', edge: selectedEdge, oldLength: oldLength, oldUnit: oldUnit, edges: edges.slice() });
                    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
                    updateStatus(`Edge length set to ${value.toFixed(2)} ${lengthUnit.value === 'meters' ? 'm' : 'ft'}.`, "success");
                    draw();
                } else {
                    updateStatus("Please enter a valid positive number", "warning");
                }
            }
        });

        lengthInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (selectedEdge) {
                    const value = parseFloat(lengthInput.value);
                    if (!isNaN(value) && value > 0) {
                        const oldLength = selectedEdge.length;
                        const oldUnit = selectedEdge.unit;
                        selectedEdge.length = value;
                        selectedEdge.unit = lengthUnit.value;
                        undoStack.push({ action: 'setLength', edge: selectedEdge, oldLength: oldLength, oldUnit: oldUnit, edges: edges.slice() });
                        if (undoStack.length > UNDO_LIMIT) undoStack.shift();
                    }
                    lengthInput.value = '';
                    const nextEdgeIndex = (edges.indexOf(selectedEdge) + 1) % edges.length;
                    selectedEdge = edges[nextEdgeIndex];
                    lengthInput.value = selectedEdge.length || '';
                    lengthUnit.value = selectedEdge.unit || 'meters';
                    lengthInput.focus();
                    updateStatus(`Editing edge between P${selectedEdge.startIndex + 1} and P${selectedEdge.endIndex + 1}. Enter length.`, "info");
                    draw();
                    if (edges.every(edge => edge.length)) {
                        lengthInput.blur();
                        updateStatus("All edge lengths set. Use controls as needed.", "info");
                    }
                }
            }
        });

        closeShapeBtn.addEventListener('click', function() {
            if (!isShapeClosed && points.length >= 3) {
                closeShape();
            } else {
                updateStatus("Shape already closed or not enough points", "warning");
            }
        });

        addDiagonalBtn.addEventListener('click', function() {
            if (enterDiagonalMode()) {
                draw();
            }
        });

        undoBtn.addEventListener('click', function() {
            if (undoStack.length > 0) {
                const lastAction = undoStack.pop();
                if (lastAction.action === 'addPoint') {
                    points = lastAction.points;
                    if (lastAction.edge) edges.pop();
                } else if (lastAction.action === 'closeShape') {
                    isShapeClosed = false;
                    edges.pop();
                    points = lastAction.points;
                } else if (lastAction.action === 'addDiagonal') {
                    edges = lastAction.edges;
                } else if (lastAction.action === 'deleteEdge') {
                    edges = lastAction.edges;
                } else if (lastAction.action === 'setLength') {
                    lastAction.edge.length = lastAction.oldLength;
                    lastAction.edge.unit = lastAction.oldUnit;
                } else if (lastAction.action === 'dragPoint') {
                    points = lastAction.points;
                } else if (lastAction.action === 'optimize') {
                    points = lastAction.points;
                    edges = lastAction.edges;
                } else if (lastAction.action === 'slice') {
                    points = lastAction.points;
                    edges = lastAction.edges;
                    sliceMode = false;
                    sliceStartPoint = null;
                    sliceLine = null;
                    sliceLineFinalized = false;
                    sliceDirection = null;
                    sliceIntersections = [];
                    leftPoly = [];
                    rightPoly = [];
                    sliceOriginalEdges = null;
                    sideSelection.style.display = 'none';
                    confirmSliceBtn.style.display = 'none';
                }
                updateStatus("Undo performed", "info");
                draw();
            } else {
                updateStatus("No actions to undo", "warning");
            }
        });

        sliceAreaInput.addEventListener('change', function() {
            const value = parseFloat(sliceAreaInput.value);
            if (!isNaN(value) && value > 0) {
                targetSliceArea = value;
                if (areaUnit.value === 'squareFeet') {
                    targetSliceArea /= SQUARE_METERS_TO_SQUARE_FEET;
                } else if (areaUnit.value === 'acres') {
                    targetSliceArea /= SQUARE_METERS_TO_ACRES;
                }
                updateSliceStatus(`Target slice area set to ${sliceAreaInput.value} ${areaUnit.value}`, "success");
            } else {
                updateSliceStatus("Please enter a valid positive area", "warning");
            }
        });

        startSliceBtn.addEventListener('click', function() {
            if (prepareForSlicing()) {
                startSliceBtn.style.display = 'none';
                cancelSliceBtn.style.display = 'block';
            }
        });

        cancelSliceBtn.addEventListener('click', function() {
            exitSliceMode();
            startSliceBtn.style.display = 'block';
            cancelSliceBtn.style.display = 'none';
        });

        confirmSliceBtn.addEventListener('click', function() {
            confirmSlice();
            startSliceBtn.style.display = 'block';
            cancelSliceBtn.style.display = 'none';
            confirmSliceBtn.style.display = 'none';
            sideSelection.style.display = 'none';
        });

        leftSideBtn.addEventListener('click', function() {
            sliceDirection = 'left';
            adjustSliceToTargetArea();
            sideSelection.style.display = 'none';
        });

        rightSideBtn.addEventListener('click', function() {
            sliceDirection = 'right';
            adjustSliceToTargetArea();
            sideSelection.style.display = 'none';
        });

        zoomInBtn.addEventListener('click', function() {
            const zoomSpeed = 0.1;
            const newScale = Math.min(MAX_SCALE, scale * (1 + zoomSpeed));
            if (newScale !== scale) {
                const mouseX = canvas.width / 2 / scale;
                const mouseY = canvas.height / 2 / scale;
                offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
                offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
                scale = newScale;
                draw();
            }
        });

        zoomOutBtn.addEventListener('click', function() {
            const zoomSpeed = 0.1;
            const newScale = Math.max(MIN_SCALE, scale * (1 - zoomSpeed));
            if (newScale !== scale) {
                const mouseX = canvas.width / 2 / scale;
                const mouseY = canvas.height / 2 / scale;
                offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
                offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
                scale = newScale;
                draw();
            }
        });

        panButton.addEventListener('click', function() {
            isPanMode = !isPanMode;
            dragMode = false;
            diagonalMode = false;
            sliceMode = false;
            panButton.classList.toggle('active');
            dragModeBtn.classList.remove('active');
            addDiagonalBtn.classList.remove('active');
            canvas.style.cursor = isPanMode ? 'grab' : 'crosshair';
            updateStatus(isPanMode ? "Pan mode activated" : "Pan mode deactivated", "info");
            draw();
        });

        optimizeBtn.addEventListener('click', function() {
            optimizeShape();
        });

        calculateAreaBtn.addEventListener('click', function() {
            if (isShapeClosed && points.length >= 3) {
                const area = calculateArea();
                const perimeterValue = calculatePerimeter();
                updateStatus(`Area: ${area.toFixed(2)} m², Perimeter: ${perimeterValue.toFixed(2)} m`, "success");
                draw();
            } else {
                updateStatus("Please close the shape with at least 3 points", "warning");
            }
        });

        clearBtn.addEventListener('click', function() {
            points = [];
            edges = [];
            isShapeClosed = false;
            selectedEdge = null;
            scaleFactor = 1;
            undoStack = [];
            sliceMode = false;
            sliceStartPoint = null;
            sliceLine = null;
            sliceLineFinalized = false;
            sliceDirection = null;
            sliceIntersections = [];
            leftPoly = [];
            rightPoly = [];
            sliceOriginalEdges = null;
            sideSelection.style.display = 'none';
            confirmSliceBtn.style.display = 'none';
            updateStatus("Canvas cleared", "info");
            scale = 1.0;
            offsetX = 0;
            offsetY = 0;
            draw();
        });

        exportBtn.addEventListener('click', function() {
            exportData();
        });

        dragModeBtn.addEventListener('click', function() {
            if (isShapeClosed) {
                dragMode = !dragMode;
                isPanMode = false;
                diagonalMode = false;
                sliceMode = false;
                dragModeBtn.classList.toggle('active');
                panButton.classList.remove('active');
                addDiagonalBtn.classList.remove('active');
                canvas.style.cursor = dragMode ? 'move' : 'crosshair';
                updateStatus(dragMode ? "Drag mode activated" : "Drag mode deactivated", "info");
                draw();
            } else {
                updateStatus("Need a closed shape to drag points", "warning");
            }
        });

        // Set initial focus
        lengthInput.focus();
    </script>
</body>
</html>
